module Halogen.Driver
  ( Driver()
  , runUI
  ) where

import Prelude

import Control.Bind ((=<<))
import Control.Coroutine (await)
import Control.Monad.Aff (Aff(), forkAff)
import Control.Monad.Aff.AVar (AVar(), makeVar, putVar, takeVar)
import Control.Monad.Eff.Class (liftEff)
import Control.Monad.Free (runFreeM)
import Control.Monad.Rec.Class (forever)
import Control.Monad.State (runState)
import Control.Monad.Trans (lift)
import Control.Plus (Plus, empty)

import Data.NaturalTransformation (Natural())
import Data.Tuple (Tuple(..))

import DOM.HTML.Types (HTMLElement())

import Halogen.Component (Component(), renderComponent, queryComponent)
import Halogen.Effects (HalogenEffects())
import Halogen.HTML.Renderer.VirtualDOM (renderHTML)
import Halogen.Internal.VirtualDOM (VTree(), createElement, diff, patch)
import Halogen.Query (HalogenF(..))
import Halogen.Query.StateF (StateF(), stateN)
import Halogen.Query.SubscribeF (SubscribeF(..), subscribeN)
import Halogen.Internal.Address (Address(), mkAddress)

-- | Type alias for driver functions generated by `runUI` - a driver takes an
-- | input of the query algebra (`f`) and returns an `Aff` that returns when
-- | query has been fulfilled.
type Driver f eff = Natural f (Aff (HalogenEffects eff))

-- | Type alias used internally to track the driver's persistent state.
type DriverState s =
  { node :: HTMLElement
  , vtree :: VTree
  , state :: s
  , renderPending :: Boolean
  }

-- | This function is the main entry point for a Halogen based UI.
-- |
-- | The returned value contains the HTML element for the component tree that
-- | then needs attaching to the DOM, and a driver function that can be used to
-- | send actions and requests into the component hierarchy.
-- |
-- | The returned driver function allows the "outside world" to communicate
-- | with the UI - a common use case it to use the driver to changes to the
-- | application state in combination with a routing library.
runUI
  :: forall s f eff
   . Component s f (Aff (HalogenEffects eff))
  -> s
  -> Aff (HalogenEffects eff) { node :: HTMLElement, driver :: Driver f eff }
runUI c s = do
  ref <- makeVar
  case renderComponent c (mkAddress (driver ref)) s of
    Tuple html s' -> do
      let vtree = renderHTML html
          node = createElement vtree
      putVar ref { node: node, vtree: vtree, state: s', renderPending: false }
      pure { node: node, driver: driver ref }

  where

  driver :: AVar (DriverState s) -> Driver f eff
  driver ref q = do
    x <- runFreeM (eval ref) (queryComponent c q)
    render ref
    pure x

  eval
    :: AVar (DriverState s)
    -> Natural (HalogenF s f (Aff (HalogenEffects eff))) (Aff (HalogenEffects eff))
  eval ref h =
    case h of
      StateHF q -> evalState q
      SubscribeHF q -> runSubscribe q
      QueryHF q -> runAff q
      HaltHF -> empty
    where
    evalState :: Natural (StateF s) (Aff (HalogenEffects eff))
    evalState i = do
      ds <- takeVar ref
      case runState (stateN i) ds.state of
        Tuple i' s' -> do
          putVar ref { node: ds.node, vtree: ds.vtree, state: s', renderPending: true }
          pure i'

    runAff :: Natural (Aff (HalogenEffects eff)) (Aff (HalogenEffects eff))
    runAff g = do
      render ref
      g

    runSubscribe :: Natural (SubscribeF f (Aff (HalogenEffects eff))) (Aff (HalogenEffects eff))
    runSubscribe sf@(Subscribe _ next) = do
      forkAff $ subscribeN (forever (lift <<< driver ref =<< await)) sf
      pure next

  render :: AVar (DriverState s) -> Aff (HalogenEffects eff) Unit
  render ref = do
    ds <- takeVar ref
    if not ds.renderPending
      then putVar ref ds
      else case renderComponent c (mkAddress (driver ref)) ds.state of
        Tuple html s'' -> do
          let vtree' = renderHTML html
          node' <- liftEff $ patch (diff ds.vtree vtree') ds.node
          putVar ref { node: node', vtree: vtree', state: s'', renderPending: false }
